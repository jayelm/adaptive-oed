var coinWeights = [
    0.01, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 0.99
];

var arraysEqual = function(as,bs) {
    return as.length === bs.length &&
        all(idF, map2(function(a, b) { return a === b; }, as, bs));
};

var fairSingle = cache(function(sequence) {
    Enumerate(function() {
        return flip();
    });
});

var fairGroup = function(sequence, counts) {
    var yDist = fairSingle(sequence);
    var numHeads = counts[0],
        numTails = counts[1];

    var p = Math.exp(score(yDist, true));

    return score(Binomial({n: numHeads + numTails, p: p}), numHeads);
};

var biasSingle = cache(function(sequence) {
    Enumerate(function() {
        var p = uniformDraw(coinWeights);
        var sampled = repeat(sequence.length, function() { return flip(p); });
        condition(arraysEqual(sampled, sequence));
        return flip(p);
    });
});

var makeBiasGroup = function() {
    return function(sequence, counts) {
        var yDist = biasSingle(sequence);
        var numHeads = counts[0],
            numTails = counts[1];

        var p = Math.exp(score(yDist, true));

        return score(Binomial({n: numHeads + numTails, p: p}), numHeads);
    };
};

var markovSingle = cache(function(sequence) {
    Enumerate(function() {
        var transitionProb = uniformDraw(coinWeights);

        var generateSequence = function(n, flipsSoFar) {
            if (flipsSoFar.length == n) {
                return flipsSoFar;
            } else {
                var lastFlip = last(flipsSoFar);
                return generateSequence(n,
                                        append(flipsSoFar,
                                               flip(transitionProb) ? !lastFlip : lastFlip));
            }
        };
        var firstCoin = flip();
        var sampled = generateSequence(sequence.length, [firstCoin]);
        condition(arraysEqual(sampled, sequence));
        return flip( transitionProb ) ? !last(sampled) : last(sampled);
    });
});

// DECIDE: x includes experiment setting AND measurement properties?
// type is x -> y -> logp
var markovGroup = function(sequence, counts) {
    var yDist = markovSingle(sequence);
    var numHeads = counts[0],
        numTails = counts[1];

    var n = numHeads + numTails;
    var p = Math.exp(score(yDist, true));

    return score(Binomial({n: n, p: p}), numHeads);
};

var biasGroup1 = makeBiasGroup();
var biasGroup2 = makeBiasGroup();

var numParticipants = 20;

var args = {
    mNameSample: function() {
        return uniformDraw(['biasGroup1', 'fairGroup', 'markovGroup']);
    },
    mFuncs: {
        biasGroup1: biasGroup1,
        fairGroup: fairGroup,
        markovGroup: markovGroup
    },
    xSample: function() {
        return repeat(4, flip);
    },
    ySample: function() {
        var numHeads = randomInteger(numParticipants + 1);
        var numTails = numParticipants - numHeads;
        return [numHeads, numTails];
    },
    // When seq is 3, it takes a very long time!
    seq: 2
    // Terrible sampling method for comparison
    // infer: {
        // M2: function(thunk) {
            // return Infer({method: 'MCMC', samples: 10}, thunk);
        // }
    // }
};

console.log(SequentialEIG(args));
